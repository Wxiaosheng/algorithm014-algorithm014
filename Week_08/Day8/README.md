## LeetCode 191 位1的个数
编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为汉明重量）

      示例 1：
        输入：00000000000000000000000000001011
        输出：3
        解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 '1'。

      示例 3：
        输入：11111111111111111111111111111101
        输出：31
        解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 '1'。

#### 方法一： 特殊位运算
**清零最低位的1 => x = x & (x + 1)**

```javascript
var hammingWeight = function (n) { 
  let count = 0
  while (n != 0){
    n = n & (n + 1)
    count++
  }
  return count
}
```

## LeetCode 231 2的幂
给定一个整数，编写一个函数来判断它是否是 2 的幂次方。

    示例:
      输入: 0
      输出: false

      输入: 1
      输出: true

      输入: 16
      输出: true

      输入: 218
      输出: false

#### 方法一： 特殊的位运算
* 除2：n / 2 => n >> 1
* 判断奇偶性： n % 2 => n & 1

```javascript
var isPowerOfTwo = function (n) {
  if (n == 0) return false
  if (n == 1) return true
  if (n & 1 == 1) return false
  return isPowerOfTwo(n >> 1)
}
```


## LeetCode 190 颠倒二进制位
颠倒给定的 32 位无符号整数的二进制位。

    示例 1：
      输入: 00000010100101000001111010011100
      输出: 00111001011110000010100101000000
      解释: 输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596，
          因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000

    示例 2：
      输入：11111111111111111111111111111101
      输出：10111111111111111111111111111111
      解释：输入的二进制串 11111111111111111111111111111101 表示无符号整数 4294967293，
          因此返回 3221225471 其二进制表示形式为 10111111111111111111111111111111
  

提示：
* 请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。
* 在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在上面的 示例 2 中，输入表示有符号整数 -3，输出表示有符号整数 -1073741825。

#### 方法一：进制转换 + 字符串操作
* padEnd：末尾补零

```javascript
var reverseBits = function (n) {
  return parseInt(n.toString(2).split('').reverse().join('').padEnd(32, 0), 2)
}
```

#### 方法二： 位运算
* ">>>" 是无符号右移，`>>>0` 的结果 = 原来负数 + 2的32次方，负数变回无符号整数

```javascript
//  不是太理解 这一题的位运算， 几乎没接触过位运算
var reverseBits = function (n) {
  let result = 0;
  // result从右往移动空出末位 + n从左往右移动获取末位 + n次 = 倒序
  for(let i = 0;i < 32;i++){
      // 左移空出一位
      result <<= 1
      // n&1获取n的末位，result的末位换成n的末位
      result |= n & 1;
      // 右移1位
      n >>= 1;
  }
  return result >>> 0;
}
```
